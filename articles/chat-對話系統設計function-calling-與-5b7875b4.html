<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Chat 對話系統設計：Function Calling 與工具調用架構全解析">
  <title>Chat 對話系統設計：Function Calling 與工具調用架構全解析 | 知識庫</title>
  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <div class="reading-progress" id="readingProgress"></div>
  <header>
    <div class="container">
      <a href="../" class="logo">知識庫</a>
      <nav>
        <a href="../#buddhism">佛學</a>
        <a href="../#thinking">思維方法</a>
        <a href="../#ai">AI技術</a>
        <a href="../#claude">Claude Code</a>
        <a href="../#game">遊戲</a>
      </nav>
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="切換深色模式">
        <span class="theme-icon">&#9680;</span>
      </button>
    </div>
  </header>

  <main class="container">
    <article>
      <div class="article-header">
        <span class="category-badge category-other">其他</span>
        <h1>Chat 對話系統設計：Function Calling 與工具調用架構全解析</h1>
        <div class="article-meta">
          <span class="date">2026-02-18</span>
          <span class="reading-time">5 分鐘閱讀</span>
          <div class="tags"></div>
        </div>
      </div>

      <details class="article-toc" open>
        <summary>目錄</summary>
        <ol>
          <li><a href="#研究背景">研究背景</a></li><li><a href="#一-核心概念-function-calling-vs-tool-use">一、核心概念：Function Calling vs Tool Use</a></li>  <li><a href="#1-1-演進脈絡">1.1 演進脈絡</a></li>  <li><a href="#1-2-核心機制">1.2 核心機制</a></li><li><a href="#二-openai-function-calling-架構">二、OpenAI Function Calling 架構</a></li>  <li><a href="#2-1-api-參數設計">2.1 API 參數設計</a></li>  <li><a href="#2-2-完整呼叫流程-4-步驟">2.2 完整呼叫流程（4 步驟）</a></li>  <li><a href="#2-3-進階功能">2.3 進階功能</a></li><li><a href="#三-anthropic-claude-tool-use-架構">三、Anthropic Claude Tool Use 架構</a></li>  <li><a href="#3-1-設計差異">3.1 設計差異</a></li>  <li><a href="#3-2-獨特設計">3.2 獨特設計</a></li><li><a href="#四-mcp-model-context-protocol-標準化架構">四、MCP（Model Context Protocol）標準化架構</a></li>  <li><a href="#4-1-協議概述">4.1 協議概述</a></li>  <li><a href="#4-2-三層角色模型">4.2 三層角色模型</a></li>  <li><a href="#4-3-server-提供三大能力">4.3 Server 提供三大能力</a></li>  <li><a href="#4-4-工具調用協議流程">4.4 工具調用協議流程</a></li>  <li><a href="#4-5-傳輸機制">4.5 傳輸機制</a></li>  <li><a href="#4-6-生命週期管理">4.6 生命週期管理</a></li>  <li><a href="#4-7-安全設計原則">4.7 安全設計原則</a></li><li><a href="#五-生產環境設計模式">五、生產環境設計模式</a></li>  <li><a href="#5-1-工具定義最佳實踐">5.1 工具定義最佳實踐</a></li>  <li><a href="#5-2-對話管理架構">5.2 對話管理架構</a></li>  <li><a href="#5-3-防護措施">5.3 防護措施</a></li>  <li><a href="#5-4-多輪對話中的工具調用">5.4 多輪對話中的工具調用</a></li><li><a href="#六-三大架構比較">六、三大架構比較</a></li><li><a href="#七-對本專案-daily-digest-prompt-的應用啟示">七、對本專案（daily-digest-prompt）的應用啟示</a></li><li><a href="#參考來源">參考來源</a></li>
        </ol>
      </details>

      <div class="article-content">
        <h1>Chat 對話系統設計：Function Calling 與工具調用架構全解析</h1>
<h2 id="研究背景">研究背景</h2>
<p>現代 AI Chat 對話系統已從單純的文字問答演進為具備「工具調用」能力的智慧代理。本研究深入分析三大主流工具調用架構——OpenAI Function Calling、Anthropic Claude Tool Use、以及開放標準 MCP（Model Context Protocol），探討其設計模式、實作流程與生產環境最佳實踐。</p>
<h2 id="一-核心概念-function-calling-vs-tool-use">一、核心概念：Function Calling vs Tool Use</h2>
<h3 id="1-1-演進脈絡">1.1 演進脈絡</h3>
<ul>
<li><strong>第一代</strong>：純文字對話（GPT-3 時代），模型只能生成文字回應</li>
<li><strong>第二代</strong>：Function Calling（2023 年 OpenAI 首創），模型可輸出結構化的函式呼叫指令</li>
<li><strong>第三代</strong>：Tool Use + MCP 標準化（2024-2025），工具調用成為跨平台開放協議</li>
</ul>
<h3 id="1-2-核心機制">1.2 核心機制</h3>
<p>Function Calling 的本質是讓 LLM 輸出<strong>結構化的工具調用意圖</strong>（非直接執行），由應用層負責實際執行並將結果回傳模型。</p>
<p><strong>關鍵設計原則</strong>：</p>
<ul>
<li>模型只負責「決定呼叫什麼函式、傳什麼參數」</li>
<li>應用層負責「實際執行函式、回傳結果」</li>
<li>人類始終在迴圈中（Human-in-the-Loop），可審核、拒絕或修改工具調用</li>
</ul>
<h2 id="二-openai-function-calling-架構">二、OpenAI Function Calling 架構</h2>
<h3 id="2-1-api-參數設計">2.1 API 參數設計</h3>
<p><code>tools</code> 是 Chat Completion API 的可選參數，用於提供函式規格：</p>
<pre><code class="language-json">{
  &quot;tools&quot;: [{
    &quot;type&quot;: &quot;function&quot;,
    &quot;function&quot;: {
      &quot;name&quot;: &quot;get_weather&quot;,
      &quot;description&quot;: &quot;取得指定地點的天氣資訊&quot;,
      &quot;parameters&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
          &quot;location&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;城市名稱&quot; },
          &quot;unit&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [&quot;celsius&quot;, &quot;fahrenheit&quot;] }
        },
        &quot;required&quot;: [&quot;location&quot;]
      }
    }
  }]
}</code></pre>
<h3 id="2-2-完整呼叫流程-4-步驟">2.2 完整呼叫流程（4 步驟）</h3>
<ol>
<li><strong>Step 1 - 發送請求</strong>：將 tools 定義 + 使用者訊息發送給模型</li>
<li><strong>Step 2 - 檢查回應</strong>：若 <code>finish_reason</code> 為 <code>tool_calls</code>，表示模型想呼叫函式</li>
<li><strong>Step 3 - 執行函式</strong>：從回應中提取函式名稱和參數，在本地執行，將結果以 <code>tool</code> 角色附加到對話</li>
<li><strong>Step 4 - 再次呼叫</strong>：將更新後的對話清單（含工具結果）再送給模型，取得最終回應</li>
</ol>
<h3 id="2-3-進階功能">2.3 進階功能</h3>
<ul>
<li><strong>Parallel Function Calling</strong>：新版模型（GPT-4o、GPT-4.1、GPT-5）支援一次呼叫多個函式，減少往返次數</li>
<li><strong>Forced Tool Use</strong>：<code>tool_choice</code> 參數可強制指定使用特定函式，或設為 <code>none</code> 禁止使用</li>
<li><strong>Structured Output</strong>：結合 JSON Schema 確保回傳格式完全符合預期</li>
</ul>
<h2 id="三-anthropic-claude-tool-use-架構">三、Anthropic Claude Tool Use 架構</h2>
<h3 id="3-1-設計差異">3.1 設計差異</h3>
<p>Claude 的 Tool Use 採用 <code>tool_use</code> / <code>tool_result</code> 區塊模型：</p>
<ul>
<li>模型回應中包含 <code>tool_use</code> 型別的 content block（含 <code>id</code>、<code>name</code>、<code>input</code>）</li>
<li>開發者執行後以 <code>tool_result</code> 型別回傳（含對應 <code>tool_use_id</code>）</li>
<li>支援串流模式（Streaming），可即時觀察模型的工具調用決策過程</li>
</ul>
<h3 id="3-2-獨特設計">3.2 獨特設計</h3>
<ul>
<li><strong>Content Block 模型</strong>：一次回應可包含混合的 text + tool_use blocks</li>
<li><strong>Tool Use ID 追蹤</strong>：每個工具呼叫有唯一 ID，結果必須對應正確 ID</li>
<li><strong>Error Handling</strong>：tool_result 支援 <code>is_error</code> 標記，模型可據此調整策略</li>
</ul>
<h2 id="四-mcp-model-context-protocol-標準化架構">四、MCP（Model Context Protocol）標準化架構</h2>
<h3 id="4-1-協議概述">4.1 協議概述</h3>
<p>MCP 是 Anthropic 推動的開放協議，目標是標準化 LLM 應用與外部工具/資料的整合方式。基於 JSON-RPC 2.0 訊息格式。</p>
<h3 id="4-2-三層角色模型">4.2 三層角色模型</h3>
<ul>
<li><strong>Host</strong>：LLM 應用程式（如 Claude Desktop、IDE 外掛），負責發起連線</li>
<li><strong>Client</strong>：Host 內部的連接器，管理與 Server 的通訊</li>
<li><strong>Server</strong>：提供工具、資源、提示模板的服務</li>
</ul>
<h3 id="4-3-server-提供三大能力">4.3 Server 提供三大能力</h3>
<ol>
<li><strong>Resources</strong>（資源）：上下文資料，供使用者或 AI 模型使用</li>
<li><strong>Prompts</strong>（提示模板）：預建的訊息範本和工作流程</li>
<li><strong>Tools</strong>（工具）：供 AI 模型執行的函式</li>
</ol>
<h3 id="4-4-工具調用協議流程">4.4 工具調用協議流程</h3>
<pre><code class="language-plaintext">1. Client → Server: tools/list（發現可用工具）
2. Server → Client: 回傳工具清單（name + description + inputSchema）
3. LLM 選擇工具 → Client: 決定呼叫哪個工具
4. Client → Server: tools/call（傳入 name + arguments）
5. Server → Client: 回傳結果（content[] + isError）
6. Client → LLM: 將結果傳給模型處理</code></pre>
<h3 id="4-5-傳輸機制">4.5 傳輸機制</h3>
<p>MCP 支援兩種標準傳輸：</p>
<ul>
<li><strong>stdio</strong>：Client 將 Server 作為子進程啟動，透過 stdin/stdout 交換 JSON-RPC 訊息</li>
<li><strong>HTTP + SSE</strong>：Server 獨立運行，透過 Server-Sent Events 推送訊息，Client 透過 POST 發送請求</li>
</ul>
<h3 id="4-6-生命週期管理">4.6 生命週期管理</h3>
<ol>
<li><strong>初始化</strong>（Initialize）：版本協商 + 能力宣告</li>
<li><strong>運作</strong>（Operation）：正常的協議通訊</li>
<li><strong>關閉</strong>（Shutdown）：優雅終止連線</li>
</ol>
<h3 id="4-7-安全設計原則">4.7 安全設計原則</h3>
<ul>
<li>使用者必須明確同意所有資料存取和操作</li>
<li>Host 必須取得使用者明確同意才能向 Server 揭露使用者資料</li>
<li>工具執行必須經使用者確認（Human-in-the-Loop）</li>
<li>Server 必須驗證所有工具輸入、實施存取控制、限制呼叫頻率、消毒輸出</li>
</ul>
<h2 id="五-生產環境設計模式">五、生產環境設計模式</h2>
<h3 id="5-1-工具定義最佳實踐">5.1 工具定義最佳實踐</h3>
<ul>
<li><strong>描述清晰</strong>：每個工具的 description 和參數 description 要讓模型能準確判斷何時使用</li>
<li><strong>Schema 嚴格</strong>：使用 JSON Schema 的 required、enum、pattern 約束參數</li>
<li><strong>命名規範</strong>：工具名稱用 snake_case，動詞開頭（get_、create_、update_、delete_）</li>
<li><strong>錯誤分級</strong>：區分協議錯誤（工具不存在）和執行錯誤（API 逾時）</li>
</ul>
<h3 id="5-2-對話管理架構">5.2 對話管理架構</h3>
<pre><code class="language-plaintext">使用者訊息 → 模型推理 → [工具調用?]
  ├─ 否 → 直接回覆
  └─ 是 → 執行工具 → 回傳結果 → 模型推理 → [再次調用?]
       ├─ 否 → 最終回覆
       └─ 是 → 遞迴（設上限防無限迴圈）</code></pre>
<h3 id="5-3-防護措施">5.3 防護措施</h3>
<ul>
<li><strong>最大迭代上限</strong>：限制工具調用的連續次數（建議 5-10 次）</li>
<li><strong>超時控制</strong>：每次工具呼叫設定 timeout</li>
<li><strong>冪等設計</strong>：工具應盡量設計為冪等操作，避免重複執行造成副作用</li>
<li><strong>結果大小限制</strong>：截斷過長的工具回傳結果，避免撐爆 context window</li>
<li><strong>敏感操作確認</strong>：寫入、刪除、支付等操作必須經使用者確認</li>
</ul>
<h3 id="5-4-多輪對話中的工具調用">5.4 多輪對話中的工具調用</h3>
<p>在多輪對話場景中，工具調用歷史會累積在對話中。關鍵考量：</p>
<ul>
<li><strong>上下文裁剪</strong>：舊的工具調用結果可摘要化，減少 Token 消耗</li>
<li><strong>狀態管理</strong>：追蹤哪些工具已呼叫、結果是否過期</li>
<li><strong>快取策略</strong>：相同參數的工具呼叫結果可快取，避免重複 API 請求</li>
</ul>
<h2 id="六-三大架構比較">六、三大架構比較</h2>
<table>
<tr><th>面向</th><th>OpenAI Function Calling</th><th>Claude Tool Use</th><th>MCP</th></tr>
<tr><td>協議格式</td><td>自定義 JSON</td><td>自定義 JSON</td><td>JSON-RPC 2.0</td></tr>
<tr><td>並行呼叫</td><td>支援</td><td>支援</td><td>支援</td></tr>
<tr><td>串流支援</td><td>部分</td><td>原生</td><td>依傳輸層</td></tr>
<tr><td>標準化程度</td><td>廠商鎖定</td><td>廠商鎖定</td><td>開放標準</td></tr>
<tr><td>工具發現</td><td>靜態定義</td><td>靜態定義</td><td>動態（tools/list）</td></tr>
<tr><td>生態系統</td><td>最廣泛</td><td>快速成長</td><td>跨平台</td></tr>
</table>
<h2 id="七-對本專案-daily-digest-prompt-的應用啟示">七、對本專案（daily-digest-prompt）的應用啟示</h2>
<p>本專案的 Todoist 路由系統（routing.yaml）本質上就是一套工具調用架構：</p>
<ol>
<li><strong>工具發現</strong>：SKILL_INDEX.md 對應 tools/list</li>
<li><strong>路由決策</strong>：三層路由規則對應模型的工具選擇邏輯</li>
<li><strong>子 Agent 模板</strong>：templates/sub-agent/*.md 對應各工具的執行邏輯</li>
<li><strong>結果組裝</strong>：todoist-assemble.md 對應工具結果的後處理</li>
</ol>
<p>若未來要建構 Chat 對話系統，可直接採用 MCP 協議，將現有 Skills 封裝為 MCP Server，實現：</p>
<ul>
<li>動態工具發現（新增 Skill 自動可用）</li>
<li>標準化的呼叫與錯誤處理</li>
<li>跨 LLM 平台相容（不綁定特定模型供應商）</li>
</ul>
<h2 id="參考來源">參考來源</h2>
<ul>
<li>OpenAI Cookbook: How to call functions with chat models（platform.openai.com/docs）</li>
<li>Anthropic Claude API Docs: Tool use with Claude（docs.anthropic.com）</li>
<li>MCP Specification 2024-11-05（spec.modelcontextprotocol.io）</li>
<li>MCP Tools Specification（Server Features &gt; Tools）</li>
<li>MCP Base Protocol &amp; Lifecycle Specification</li>
</ul>

      </div>

      <nav class="article-nav"><a href="skill-品質審查報告2026-02-19todoi-30a8e9cd.html" class="nav-prev"><span class="nav-label">&larr; 上一篇</span><span class="nav-title">Skill 品質審查報告（2026-02-19）：todoist-task-creator + web-research 深度審查</span></a><a href="skill-品質審查報告2026-02-18syste-332495c6.html" class="nav-next"><span class="nav-label">下一篇 &rarr;</span><span class="nav-title">Skill 品質審查報告（2026-02-18）：system-audit + kb-curator 深度審查</span></a></nav>

      <a href="../" class="back-link">&larr; 返回首頁</a>
    </article>
  </main>

  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})" aria-label="回到頂部">&uarr;</button>

  <footer>
    <div class="container">
      <p>Powered by RAG Knowledge Base</p>
    </div>
  </footer>
  <script>
    function toggleTheme(){const b=document.body;b.classList.toggle('dark');localStorage.setItem('theme',b.classList.contains('dark')?'dark':'light')}
    if(localStorage.getItem('theme')==='dark')document.body.classList.add('dark');
    window.addEventListener('scroll',function(){
      const prog=document.getElementById('readingProgress');
      const btn=document.getElementById('backToTop');
      const h=document.documentElement.scrollHeight-window.innerHeight;
      const pct=h>0?(window.scrollY/h)*100:0;
      prog.style.width=pct+'%';
      btn.classList.toggle('visible',window.scrollY>300);
    });
  </script>
</body>
</html>
