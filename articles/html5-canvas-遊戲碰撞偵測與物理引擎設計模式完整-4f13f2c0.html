<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="HTML5 Canvas 遊戲碰撞偵測與物理引擎設計模式完整指南">
  <title>HTML5 Canvas 遊戲碰撞偵測與物理引擎設計模式完整指南 | 知識庫</title>
  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <header>
    <div class="container">
      <a href="../" class="logo">知識庫</a>
      <nav>
        <a href="../#buddhism">佛學</a>
        <a href="../#thinking">思維方法</a>
        <a href="../#ai">AI技術</a>
        <a href="../#claude">Claude Code</a>
        <a href="../#game">遊戲</a>
      </nav>
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="切換深色模式">
        <span class="theme-icon">◐</span>
      </button>
    </div>
  </header>

  <main class="container">
    <article>
      <div class="article-header">
        <span class="category-badge category-game">遊戲開發</span>
        <h1>HTML5 Canvas 遊戲碰撞偵測與物理引擎設計模式完整指南</h1>
        <div class="article-meta">
          <span class="date">2026-02-15</span>
          <div class="tags"><span class="tag">遊戲設計</span><span class="tag">碰撞偵測</span><span class="tag">HTML5</span><span class="tag">物理引擎</span><span class="tag">AABB</span><span class="tag">SAT</span><span class="tag">Canvas</span><span class="tag">效能優化</span></div>
        </div>
      </div>

      <div class="article-content">
        <h1>HTML5 Canvas 遊戲碰撞偵測與物理引擎設計模式完整指南</h1>
<h2>概述</h2>
<p>碰撞偵測是 HTML5 遊戲開發的核心技術之一。本文系統性整理三種主要碰撞偵測演算法（AABB、圓形碰撞、SAT）、物理引擎架構（廣相/窄相分離）、效能優化策略，以及實際開發中的最佳實踐。</p>
<hr>
<h2>一、碰撞偵測演算法</h2>
<h3>1. AABB（Axis-Aligned Bounding Box）</h3>
<p>最簡單高效的碰撞偵測方法，適用於未旋轉的矩形物件。</p>
<p><strong>原理</strong>：檢查兩個矩形在 X 軸和 Y 軸上是否同時重疊。</p>
<pre><code class="language-javascript">function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    if (x2 &gt; w1 + x1 || x1 &gt; w2 + x2 || y2 &gt; h1 + y1 || y1 &gt; h2 + y2) {
        return false;
    }
    return true;
}</code></pre>
<p><strong>效能基準</strong>：1000 個物件約 5ms（極快）</p>
<p><strong>適用場景</strong>：</p>
<ul>
<li>平台跳躍遊戲（角色與平台碰撞）</li>
<li>俯視射擊遊戲（子彈與敵人碰撞）</li>
<li>任何以矩形為主的遊戲</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>不支援旋轉物件</li>
<li>對非矩形物件會產生誤判（false positive）</li>
</ul>
<h3>2. 圓形碰撞偵測</h3>
<p>基於兩圓心距離的偵測方法，適合圓形或近圓形物件。</p>
<p><strong>原理</strong>：若兩圓心距離 &lt;= 兩半徑之和，則碰撞。</p>
<pre><code class="language-javascript">function circleIntersect(x1, y1, r1, x2, y2, r2) {
    // 使用平方距離避免 Math.sqrt()，效能更好
    let squareDistance = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    return squareDistance &lt;= (r1 + r2) * (r1 + r2);
}</code></pre>
<p><strong>效能技巧</strong>：比較平方距離而非實際距離，省去 Math.sqrt() 運算（乘法比開方快很多）。</p>
<p><strong>適用場景</strong>：</p>
<ul>
<li>彈珠台、泡泡射手</li>
<li>行星/太空遊戲</li>
<li>任何以圓形碰撞體為主的遊戲</li>
</ul>
<h3>3. SAT（Separating Axis Theorem）</h3>
<p>最精確的凸多邊形碰撞偵測方法。</p>
<p><strong>原理</strong>：將兩個凸多邊形投影到所有可能的分離軸上。若存在任何一個軸使得投影不重疊，則無碰撞。若所有軸的投影都重疊，則碰撞。</p>
<pre><code class="language-javascript">function satCollision(shape1, shape2) {
    const axes = [...shape1.getNormals(), ...shape2.getNormals()];
    for (const axis of axes) {
        const proj1 = project(shape1, axis);
        const proj2 = project(shape2, axis);
        if (!overlap(proj1, proj2)) {
            return false; // 找到分離軸，無碰撞
        }
    }
    return true; // 所有軸都重疊，確認碰撞
}</code></pre>
<p><strong>效能基準</strong>：1000 個物件約 50ms（比 AABB 慢 10 倍）</p>
<p><strong>適用場景</strong>：</p>
<ul>
<li>需要精確碰撞的遊戲（賽車遊戲的車體碰撞）</li>
<li>旋轉物件互動（俄羅斯方塊變體）</li>
<li>不規則多邊形碰撞</li>
</ul>
<hr>
<h2>二、混合碰撞架構（廣相 + 窄相）</h2>
<h3>三層碰撞系統</h3>
<p>現代遊戲引擎普遍採用分層架構，平衡精確度與效能：</p>
<table>
<tr><th>階段</th><th>方法</th><th>目的</th><th>計算成本</th></tr>
<tr><td>廣相（Broad Phase）</td><td>空間分割</td><td>快速排除遠距物件</td><td>極低</td></tr>
<tr><td>中相（Mid Phase）</td><td>AABB</td><td>進一步篩選候選對</td><td>低</td></tr>
<tr><td>窄相（Narrow Phase）</td><td>SAT / 精確偵測</td><td>確認實際碰撞</td><td>較高</td></tr>
</table>
<h3>空間分割技術</h3>
<p>#### Quadtree（四叉樹）
將 2D 空間遞迴分割為四個象限，物件只與同象限的物件做碰撞檢查。</p>
<ul>
<li>適合物件分布不均勻的場景</li>
<li>插入/查詢時間 O(log n)</li>
</ul>
<p>#### Uniform Grid（均勻網格）
將空間劃分為等大的格子，物件只與相鄰格子的物件碰撞檢查。</p>
<ul>
<li>適合物件大小相近且分布均勻的場景</li>
<li>格子大小應接近平均物件尺寸</li>
</ul>
<pre><code class="language-javascript">const worldAABB = new b2AABB();
worldAABB.lowerBound.Set(-100, -100);
worldAABB.upperBound.Set(100, 100);
const gridSize = 10; // 匹配平均物件尺寸</code></pre>
<p>#### Spatial Hashing（空間雜湊）
使用雜湊函數將物件位置映射到桶（bucket），同桶物件才做碰撞檢查。</p>
<ul>
<li>記憶體效率高</li>
<li>適合大型稀疏場景</li>
</ul>
<p>#### Sweep and Prune（掃描剪枝）
沿座標軸排序物件的邊界端點，只有投影重疊的物件才進行碰撞檢查。</p>
<ul>
<li>利用時間連續性（temporal coherence）</li>
<li>適合物件緩慢移動的場景</li>
</ul>
<hr>
<h2>三、碰撞回應（Collision Response）</h2>
<h3>基本物理模擬</h3>
<pre><code class="language-javascript">// 速度更新
this.x += this.vx * secondsPassed;
this.y += this.vy * secondsPassed;

// 重力
this.vy += gravity * secondsPassed;</code></pre>
<h3>材質屬性影響碰撞回應</h3>
<table>
<tr><th>材質</th><th>摩擦力(friction)</th><th>恢復係數(restitution)</th></tr>
<tr><td>木材</td><td>0.4</td><td>0.2</td></tr>
<tr><td>金屬</td><td>0.2</td><td>0.15</td></tr>
<tr><td>冰面</td><td>0.02</td><td>0.1</td></tr>
<tr><td>橡膠</td><td>0.8</td><td>0.8</td></tr>
</table>
<h3>固定時間步長（Fixed Timestep）</h3>
<p>確保物理模擬不受幀率波動影響：</p>
<pre><code class="language-javascript">const PHYSICS_STEP = 1 / 60;
let accumulator = 0;

function gameLoop(timestamp) {
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    accumulator += deltaTime;

    while (accumulator &gt;= PHYSICS_STEP) {
        physicsWorld.step(PHYSICS_STEP);
        accumulator -= PHYSICS_STEP;
    }

    render();
    requestAnimationFrame(gameLoop);
}</code></pre>
<hr>
<h2>四、效能優化策略</h2>
<h3>1. 物件池（Object Pooling）</h3>
<p>預先建立物理物件，避免頻繁的垃圾回收暫停。</p>
<h3>2. 休眠機制（Sleep Mechanism）</h3>
<p>將靜止物件設為休眠狀態，不參與碰撞計算：</p>
<pre><code class="language-javascript">const sleepConfig = { timeToSleep: 0.5 };</code></pre>
<h3>3. 自適應品質</h3>
<p>根據裝置效能調整碰撞精度：</p>
<ul>
<li>高效能裝置：velocityIterations = 8</li>
<li>低效能裝置：velocityIterations = 4</li>
</ul>
<h3>4. 形狀簡化</h3>
<p>使用簡化的碰撞形狀（而非精確輪廓）減少計算量。</p>
<h3>5. 迴圈優化</h3>
<p>避免重複比較與自碰撞：</p>
<pre><code class="language-javascript">for (let i = 0; i &lt; objects.length; i++) {
    for (let j = i + 1; j &lt; objects.length; j++) {
        // 只比較唯一配對
    }
}</code></pre>
<h3>6. 每幀重置碰撞狀態</h3>
<p>正確順序：更新所有物件 -&gt; 碰撞偵測 -&gt; 清除畫布 -&gt; 繪製。</p>
<hr>
<h2>五、JS 物理引擎選型指南</h2>
<table>
<tr><th>引擎</th><th>大小</th><th>特色</th><th>適用場景</th></tr>
<tr><td>Matter.js</td><td>~70KB</td><td>API 友善、文件完整</td><td>中等複雜度的 2D 遊戲</td></tr>
<tr><td>Planck.js</td><td>~95KB</td><td>Box2D 的 JS 移植</td><td>需要精確物理的 2D 遊戲</td></tr>
<tr><td>p2-es</td><td>~100KB</td><td>約束/彈簧/馬達豐富</td><td>進階物理模擬</td></tr>
<tr><td>Box2D.js</td><td>較大</td><td>業界標準、效能 9/10</td><td>大型或效能要求高的遊戲</td></tr>
</table>
<p><strong>選擇建議</strong>：</p>
<ul>
<li>小型/原型遊戲 -&gt; 自製碰撞偵測（AABB + 圓形）</li>
<li>中型遊戲 -&gt; Matter.js（學習曲線低、文件好）</li>
<li>大型遊戲 -&gt; Planck.js 或 Box2D.js（效能與精確度最佳）</li>
</ul>
<hr>
<h2>六、設計模式決策樹</h2>
<pre><code class="language-plaintext">你的遊戲需要碰撞偵測嗎？
|-- 物件都是矩形且不旋轉 -&gt; AABB
|-- 物件都是圓形 -&gt; 圓形碰撞
|-- 物件是凸多邊形或會旋轉 -&gt; SAT
|-- 物件 &gt; 50 個 -&gt; 加上廣相（Quadtree 或 Spatial Hash）
|-- 需要完整物理（重力、摩擦、彈跳）-&gt; 使用物理引擎</code></pre>
<hr>
<h2>七、關鍵數據</h2>
<ul>
<li>使用物理引擎的 HTML5 遊戲，玩家平均 session 時長提升 43%</li>
<li>AABB 比 SAT 快約 10 倍（1000 物件：5ms vs 50ms）</li>
<li>平方距離比較比 Math.sqrt() 快 3-5 倍</li>
<li>固定時間步長（1/60s）確保跨裝置一致的物理行為</li>
</ul>
<hr>
<h2>參考來源</h2>
<ol>
<li><a href="https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics">Collision Detection and Physics - Spicy Yoghurt</a></li>
<li><a href="https://peerdh.com/blogs/programming-insights/benchmarking-aabb-vs-sat-in-game-collision-detection">Benchmarking AABB vs SAT - PeerDH</a></li>
<li><a href="https://playgama.com/blog/general/enhance-your-html5-games-with-realistic-physics-implementation/">Enhance HTML5 Games with Physics - Playgama</a></li>
<li><a href="http://buildnewgames.com/broad-phase-collision-detection/">Broad Phase Collision Detection - BuildNewGames</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Collision_detection">Collision Detection - MDN Web Docs</a></li>
<li><a href="https://www.toptal.com/game/video-game-physics-part-ii-collision-detection-for-solid-objects">Video Game Physics Part II - Toptal</a></li>
<li><a href="https://developer.ibm.com/tutorials/wa-build2dphysicsengine/">Build a 2D Physics Engine - IBM Developer</a></li>
</ol>
<hr>
<p><em>研究日期：2026-02-16</em>
<em>研究者：Claude Code Agent</em></p>

      </div>

      <a href="../" class="back-link">&larr; 返回首頁</a>
    </article>
  </main>

  <footer>
    <div class="container">
      <p>Powered by RAG Knowledge Base</p>
    </div>
  </footer>
  <script>
    function toggleTheme(){const b=document.body;b.classList.toggle('dark');localStorage.setItem('theme',b.classList.contains('dark')?'dark':'light')}
    if(localStorage.getItem('theme')==='dark')document.body.classList.add('dark');
  </script>
</body>
</html>
